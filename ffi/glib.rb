# Generated by ffi_gen. Please do not change this file by hand.

require 'ffi'

module GLIB
  extend FFI::Library
  ffi_lib 'gobject-2.0'
  
  SIGNAL_FLAGS_MASK = 0xff
  
  SIGNAL_MATCH_MASK = 0x3f
  
  # for historic reasons, C++ links against gulong GTypes
  class GValue < FFI::Struct
    layout :dummy, :char
  end
  
  # (Not documented)
  class GTypeCValue < FFI::Union
    layout :dummy, :char
  end
  
  # (Not documented)
  class GTypePlugin < FFI::Struct
    layout :dummy, :char
  end
  
  # GTypeClass:
  # 
  # An opaque structure used as the base of all classes.
  # 
  # = Fields:
  # :type ::
  #   (Integer) < private >
  class GTypeClass < FFI::Struct
    layout :type, :ulong
  end
  
  # GTypeInstance:
  # 
  # An opaque structure used as the base of all type instances.
  # 
  # = Fields:
  # :class ::
  #   (GTypeClass) < private >
  class GTypeInstance < FFI::Struct
    layout :class, GTypeClass
  end
  
  # GTypeInterface:
  # 
  # An opaque structure used as the base of all interface types.
  # 
  # = Fields:
  # :type ::
  #   (Integer) iface type
  # :instance_type ::
  #   (Integer) 
  class GTypeInterface < FFI::Struct
    layout :type, :ulong,
           :instance_type, :ulong
  end
  
  # GTypeQuery:
  # @type: the #GType value of the type.
  # @type_name: the name of the type.
  # @class_size: the size of the class structure.
  # @instance_size: the size of the instance structure.
  # 
  # A structure holding information for a specific type. It is
  # filled in by the g_type_query() function.
  # 
  # = Fields:
  # :type ::
  #   (Integer) 
  # :type_name ::
  #   (String) 
  # :class_size ::
  #   (Integer) 
  # :instance_size ::
  #   (Integer) 
  class GTypeQuery < FFI::Struct
    layout :type, :ulong,
           :type_name, :string,
           :class_size, :uint,
           :instance_size, :uint
  end
  
  # GTypeDebugFlags:
  # @G_TYPE_DEBUG_NONE: Print no messages.
  # @G_TYPE_DEBUG_OBJECTS: Print messages about object bookkeeping.
  # @G_TYPE_DEBUG_SIGNALS: Print messages about signal emissions.
  # @G_TYPE_DEBUG_MASK: Mask covering all debug flags.
  # 
  # The <type>GTypeDebugFlags</type> enumeration values can be passed to
  # g_type_init_with_debug_flags() to trigger debugging messages during runtime.
  # Note that the messages can also be triggered by setting the
  # <envar>GOBJECT_DEBUG</envar> environment variable to a ':'-separated list of 
  # "objects" and "signals".
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_type_debug_flags).</em>
  # 
  # === Options:
  # :none ::
  #   < skip >
  # :mask ::
  #   
  # 
  # @method _enum_g_type_debug_flags_
  # @return [Symbol]
  # @scope class
  enum :g_type_debug_flags, [
    :none, 0,
    :mask, 0x03
  ]
  
  # --- prototypes ---
  # 
  # @method type_init()
  # @return [nil] 
  # @scope class
  attach_function :type_init, :g_type_init, [], :void
  
  # (Not documented)
  # 
  # @method type_init_with_debug_flags(debug_flags)
  # @param [Symbol from _enum_g_type_debug_flags_] debug_flags 
  # @return [nil] 
  # @scope class
  attach_function :type_init_with_debug_flags, :g_type_init_with_debug_flags, [:g_type_debug_flags], :void
  
  # (Not documented)
  # 
  # @method type_name(type)
  # @param [Integer] type 
  # @return [String] 
  # @scope class
  attach_function :type_name, :g_type_name, [:ulong], :string
  
  # (Not documented)
  # 
  # @method type_qname(type)
  # @param [Integer] type 
  # @return [Integer] 
  # @scope class
  attach_function :type_qname, :g_type_qname, [:ulong], :uint
  
  # (Not documented)
  # 
  # @method type_from_name(name)
  # @param [String] name 
  # @return [Integer] 
  # @scope class
  attach_function :type_from_name, :g_type_from_name, [:string], :ulong
  
  # (Not documented)
  # 
  # @method type_parent(type)
  # @param [Integer] type 
  # @return [Integer] 
  # @scope class
  attach_function :type_parent, :g_type_parent, [:ulong], :ulong
  
  # (Not documented)
  # 
  # @method type_depth(type)
  # @param [Integer] type 
  # @return [Integer] 
  # @scope class
  attach_function :type_depth, :g_type_depth, [:ulong], :uint
  
  # (Not documented)
  # 
  # @method type_next_base(leaf_type, root_type)
  # @param [Integer] leaf_type 
  # @param [Integer] root_type 
  # @return [Integer] 
  # @scope class
  attach_function :type_next_base, :g_type_next_base, [:ulong, :ulong], :ulong
  
  # (Not documented)
  # 
  # @method type_is_a(type, is_a_type)
  # @param [Integer] type 
  # @param [Integer] is_a_type 
  # @return [Integer] 
  # @scope class
  attach_function :type_is_a, :g_type_is_a, [:ulong, :ulong], :int
  
  # (Not documented)
  # 
  # @method type_class_ref(type)
  # @param [Integer] type 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :type_class_ref, :g_type_class_ref, [:ulong], :pointer
  
  # (Not documented)
  # 
  # @method type_class_peek(type)
  # @param [Integer] type 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :type_class_peek, :g_type_class_peek, [:ulong], :pointer
  
  # (Not documented)
  # 
  # @method type_class_peek_static(type)
  # @param [Integer] type 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :type_class_peek_static, :g_type_class_peek_static, [:ulong], :pointer
  
  # (Not documented)
  # 
  # @method type_class_unref(class)
  # @param [FFI::Pointer(Gpointer)] class 
  # @return [nil] 
  # @scope class
  attach_function :type_class_unref, :g_type_class_unref, [:pointer], :void
  
  # (Not documented)
  # 
  # @method type_class_peek_parent(class)
  # @param [FFI::Pointer(Gpointer)] class 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :type_class_peek_parent, :g_type_class_peek_parent, [:pointer], :pointer
  
  # (Not documented)
  # 
  # @method type_interface_peek(instance_class, iface_type)
  # @param [FFI::Pointer(Gpointer)] instance_class 
  # @param [Integer] iface_type 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :type_interface_peek, :g_type_interface_peek, [:pointer, :ulong], :pointer
  
  # (Not documented)
  # 
  # @method type_interface_peek_parent(iface)
  # @param [FFI::Pointer(Gpointer)] iface 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :type_interface_peek_parent, :g_type_interface_peek_parent, [:pointer], :pointer
  
  # (Not documented)
  # 
  # @method type_default_interface_ref(type)
  # @param [Integer] type 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :type_default_interface_ref, :g_type_default_interface_ref, [:ulong], :pointer
  
  # (Not documented)
  # 
  # @method type_default_interface_peek(type)
  # @param [Integer] type 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :type_default_interface_peek, :g_type_default_interface_peek, [:ulong], :pointer
  
  # (Not documented)
  # 
  # @method type_default_interface_unref(iface)
  # @param [FFI::Pointer(Gpointer)] iface 
  # @return [nil] 
  # @scope class
  attach_function :type_default_interface_unref, :g_type_default_interface_unref, [:pointer], :void
  
  # g_free() the returned arrays
  # 
  # @method type_children(type, n_children)
  # @param [Integer] type 
  # @param [FFI::Pointer(*Guint)] n_children 
  # @return [FFI::Pointer(*GType)] 
  # @scope class
  attach_function :type_children, :g_type_children, [:ulong, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method type_interfaces(type, n_interfaces)
  # @param [Integer] type 
  # @param [FFI::Pointer(*Guint)] n_interfaces 
  # @return [FFI::Pointer(*GType)] 
  # @scope class
  attach_function :type_interfaces, :g_type_interfaces, [:ulong, :pointer], :pointer
  
  # per-type _static_ data
  # 
  # @method type_set_qdata(type, quark, data)
  # @param [Integer] type 
  # @param [Integer] quark 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [nil] 
  # @scope class
  attach_function :type_set_qdata, :g_type_set_qdata, [:ulong, :uint, :pointer], :void
  
  # (Not documented)
  # 
  # @method type_get_qdata(type, quark)
  # @param [Integer] type 
  # @param [Integer] quark 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :type_get_qdata, :g_type_get_qdata, [:ulong, :uint], :pointer
  
  # (Not documented)
  # 
  # @method type_query(type, query)
  # @param [Integer] type 
  # @param [GTypeQuery] query 
  # @return [nil] 
  # @scope class
  attach_function :type_query, :g_type_query, [:ulong, GTypeQuery], :void
  
  # GClassInitFunc:
  # @g_class: The #GTypeClass structure to initialize.
  # @class_data: The @class_data member supplied via the #GTypeInfo structure.
  # 
  # A callback function used by the type system to initialize the class
  # of a specific type. This function should initialize all static class
  # members.
  # The initialization process of a class involves:
  # <itemizedlist>
  # <listitem><para>
  # 	1 - Copying common members from the parent class over to the
  # 	derived class structure.
  # </para></listitem>
  # <listitem><para>
  # 	2 -  Zero initialization of the remaining members not copied
  # 	over from the parent class.
  # </para></listitem>
  # <listitem><para>
  # 	3 - Invocation of the GBaseInitFunc() initializers of all parent
  # 	types and the class' type.
  # </para></listitem>
  # <listitem><para>
  # 	4 - Invocation of the class' GClassInitFunc() initializer.
  # </para></listitem>
  # </itemizedlist>
  # Since derived classes are partially initialized through a memory copy
  # of the parent class, the general rule is that GBaseInitFunc() and
  # GBaseFinalizeFunc() should take care of necessary reinitialization
  # and release of those class members that were introduced by the type
  # that specified these GBaseInitFunc()/GBaseFinalizeFunc().
  # GClassInitFunc() should only care about initializing static
  # class members, while dynamic class members (such as allocated strings
  # or reference counted resources) are better handled by a GBaseInitFunc()
  # for this type, so proper initialization of the dynamic class members
  # is performed for class initialization of derived types as well.
  # An example may help to correspond the intend of the different class
  # initializers:
  # 
  # |(
  # typedef struct {
  #   GObjectClass parent_class;
  #   gint         static_integer;
  #   gchar       *dynamic_string;
  # } TypeAClass;
  # static void
  # type_a_base_class_init (TypeAClass *class)
  # {
  #   class->dynamic_string = g_strdup ("some string");
  # }
  # static void
  # type_a_base_class_finalize (TypeAClass *class)
  # {
  #   g_free (class->dynamic_string);
  # }
  # static void
  # type_a_class_init (TypeAClass *class)
  # {
  #   class->static_integer = 42;
  # }
  # 
  # typedef struct {
  #   TypeAClass   parent_class;
  #   gfloat       static_float;
  #   GString     *dynamic_gstring;
  # } TypeBClass;
  # static void
  # type_b_base_class_init (TypeBClass *class)
  # {
  #   class->dynamic_gstring = g_string_new ("some other string");
  # }
  # static void
  # type_b_base_class_finalize (TypeBClass *class)
  # {
  #   g_string_free (class->dynamic_gstring);
  # }
  # static void
  # type_b_class_init (TypeBClass *class)
  # {
  #   class->static_float = 3.14159265358979323846;
  # }
  # )|
  # Initialization of TypeBClass will first cause initialization of
  # TypeAClass (derived classes reference their parent classes, see
  # g_type_class_ref() on this).
  # Initialization of TypeAClass roughly involves zero-initializing its fields,
  # then calling its GBaseInitFunc() type_a_base_class_init() to allocate
  # its dynamic members (dynamic_string), and finally calling its GClassInitFunc()
  # type_a_class_init() to initialize its static members (static_integer).
  # The first step in the initialization process of TypeBClass is then
  # a plain memory copy of the contents of TypeAClass into TypeBClass and 
  # zero-initialization of the remaining fields in TypeBClass.
  # The dynamic members of TypeAClass within TypeBClass now need
  # reinitialization which is performed by calling type_a_base_class_init()
  # with an argument of TypeBClass.
  # After that, the GBaseInitFunc() of TypeBClass, type_b_base_class_init()
  # is called to allocate the dynamic members of TypeBClass (dynamic_gstring),
  # and finally the GClassInitFunc() of TypeBClass, type_b_class_init(),
  # is called to complete the initialization process with the static members
  # (static_float).
  # Corresponding finalization counter parts to the GBaseInitFunc() functions
  # have to be provided to release allocated resources at class finalization
  # time.
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_class_init_func_(class_data)
  # @param [FFI::Pointer(Gpointer)] class_data 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  callback :g_class_init_func, [:pointer], :pointer
  
  # GClassFinalizeFunc:
  # @g_class: The #GTypeClass structure to finalize.
  # @class_data: The @class_data member supplied via the #GTypeInfo structure.
  # 
  # A callback function used by the type system to finalize a class.
  # This function is rarely needed, as dynamically allocated class resources
  # should be handled by GBaseInitFunc() and GBaseFinalizeFunc().
  # Also, specification of a GClassFinalizeFunc() in the #GTypeInfo
  # structure of a static type is invalid, because classes of static types
  # will never be finalized (they are artificially kept alive when their
  # reference count drops to zero).
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_class_finalize_func_(class_data)
  # @param [FFI::Pointer(Gpointer)] class_data 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  callback :g_class_finalize_func, [:pointer], :pointer
  
  # GInstanceInitFunc:
  # @instance: The instance to initialize.
  # @g_class: The class of the type the instance is created for.
  # 
  # A callback function used by the type system to initialize a new
  # instance of a type. This function initializes all instance members and
  # allocates any resources required by it.
  # Initialization of a derived instance involves calling all its parent
  # types instance initializers, so the class member of the instance
  # is altered during its initialization to always point to the class that
  # belongs to the type the current initializer was introduced for.
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_instance_init_func_(class)
  # @param [FFI::Pointer(Gpointer)] class 
  # @return [GTypeInstance] 
  # @scope class
  callback :g_instance_init_func, [:pointer], GTypeInstance
  
  # GInterfaceInitFunc:
  # @g_iface: The interface structure to initialize.
  # @iface_data: The @interface_data supplied via the #GInterfaceInfo structure.
  # 
  # A callback function used by the type system to initialize a new
  # interface.  This function should initialize all internal data and
  # allocate any resources required by the interface.
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_interface_init_func_(iface_data)
  # @param [FFI::Pointer(Gpointer)] iface_data 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  callback :g_interface_init_func, [:pointer], :pointer
  
  # GInterfaceFinalizeFunc:
  # @g_iface: The interface structure to finalize.
  # @iface_data: The @interface_data supplied via the #GInterfaceInfo structure.
  # 
  # A callback function used by the type system to finalize an interface.
  # This function should destroy any internal data and release any resources
  # allocated by the corresponding GInterfaceInitFunc() function.
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_interface_finalize_func_(iface_data)
  # @param [FFI::Pointer(Gpointer)] iface_data 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  callback :g_interface_finalize_func, [:pointer], :pointer
  
  # GTypeClassCacheFunc:
  # @cache_data: data that was given to the g_type_add_class_cache_func() call
  # @g_class: The #GTypeClass structure which is unreferenced
  # 
  # A callback function which is called when the reference count of a class 
  # drops to zero. It may use g_type_class_ref() to prevent the class from
  # being freed. You should not call g_type_class_unref() from a 
  # #GTypeClassCacheFunc function to prevent infinite recursion, use 
  # g_type_class_unref_uncached() instead.
  # 
  # The functions have to check the class id passed in to figure 
  # whether they actually want to cache the class of this type, since all
  # classes are routed through the same #GTypeClassCacheFunc chain.
  # 
  # Returns: %TRUE to stop further #GTypeClassCacheFunc<!-- -->s from being 
  #  called, %FALSE to continue.
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_type_class_cache_func_(cache_data, class)
  # @param [FFI::Pointer(Gpointer)] cache_data 
  # @param [GTypeClass] class 
  # @return [Integer] 
  # @scope class
  callback :g_type_class_cache_func, [:pointer, GTypeClass], :int
  
  # GTypeInterfaceCheckFunc:
  # @check_data: data passed to g_type_add_interface_check().
  # @g_iface: the interface that has been initialized
  # 
  # A callback called after an interface vtable is initialized.
  # See g_type_add_interface_check().
  # 
  # Since: 2.4
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_type_interface_check_func_(iface)
  # @param [FFI::Pointer(Gpointer)] iface 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  callback :g_type_interface_check_func, [:pointer], :pointer
  
  # GTypeFundamentalFlags:
  # @G_TYPE_FLAG_CLASSED: Indicates a classed type.
  # @G_TYPE_FLAG_INSTANTIATABLE: Indicates an instantiable type (implies classed).
  # @G_TYPE_FLAG_DERIVABLE: Indicates a flat derivable type.
  # @G_TYPE_FLAG_DEEP_DERIVABLE: Indicates a deep derivable type (implies derivable).
  # 
  # Bit masks used to check or determine specific characteristics of a
  # fundamental type.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_type_fundamental_flags).</em>
  # 
  # === Options:
  # 
  # @method _enum_g_type_fundamental_flags_
  # @return [Symbol]
  # @scope class
  enum :g_type_fundamental_flags, [
  ]
  
  # GTypeFlags:
  # @G_TYPE_FLAG_ABSTRACT: Indicates an abstract type. No instances can be
  #  created for an abstract type.
  # @G_TYPE_FLAG_VALUE_ABSTRACT: Indicates an abstract value type, i.e. a type
  #  that introduces a value table, but can't be used for
  #  g_value_init().
  # 
  # Bit masks used to check or determine characteristics of a type.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_type_flags).</em>
  # 
  # === Options:
  # 
  # @method _enum_g_type_flags_
  # @return [Symbol]
  # @scope class
  enum :g_type_flags, [
  ]
  
  # GTypeInfo:
  # @class_size: Size of the class structure (required for interface, classed and instantiatable types).
  # @base_init: Location of the base initialization function (optional).
  # @base_finalize: Location of the base finalization function (optional).
  # @class_init: Location of the class initialization function for
  #  classed and instantiatable types. Location of the default vtable 
  #  inititalization function for interface types. (optional) This function 
  #  is used both to fill in virtual functions in the class or default vtable, 
  #  and to do type-specific setup such as registering signals and object
  #  properties.
  # @class_finalize: Location of the class finalization function for
  #  classed and instantiatable types. Location fo the default vtable 
  #  finalization function for interface types. (optional)
  # @class_data: User-supplied data passed to the class init/finalize functions.
  # @instance_size: Size of the instance (object) structure (required for instantiatable types only).
  # @n_preallocs: Prior to GLib 2.10, it specified the number of pre-allocated (cached) instances to reserve memory for (0 indicates no caching). Since GLib 2.10, it is ignored, since instances are allocated with the <link linkend="glib-Memory-Slices">slice allocator</link> now.
  # @instance_init: Location of the instance initialization function (optional, for instantiatable types only).
  # @value_table: A #GTypeValueTable function table for generic handling of GValues of this type (usually only
  #  useful for fundamental types).
  # 
  # This structure is used to provide the type system with the information
  # required to initialize and destruct (finalize) a type's class and
  # its instances.
  # The initialized structure is passed to the g_type_register_static() function
  # (or is copied into the provided #GTypeInfo structure in the
  # g_type_plugin_complete_type_info()). The type system will perform a deep
  # copy of this structure, so its memory does not need to be persistent
  # across invocation of g_type_register_static().
  # 
  # = Fields:
  # :class_size ::
  #   (Integer) interface types, classed types, instantiated types
  # :base_init ::
  #   (FFI::Pointer(GBaseInitFunc)) 
  # :base_finalize ::
  #   (FFI::Pointer(GBaseFinalizeFunc)) 
  # :class_init ::
  #   (Proc(_callback_g_class_init_func_)) interface types, classed types, instantiated types
  # :class_finalize ::
  #   (Proc(_callback_g_class_finalize_func_)) 
  # :class_data ::
  #   (FFI::Pointer(Gconstpointer)) 
  # :instance_size ::
  #   (Integer) instantiated types
  # :n_preallocs ::
  #   (Integer) 
  # :instance_init ::
  #   (Proc(_callback_g_instance_init_func_)) 
  # :value_table ::
  #   (FFI::Pointer(*GTypeValueTable)) value handling
  class GTypeInfo < FFI::Struct
    layout :class_size, :ushort,
           :base_init, :pointer,
           :base_finalize, :pointer,
           :class_init, :g_class_init_func,
           :class_finalize, :g_class_finalize_func,
           :class_data, :pointer,
           :instance_size, :ushort,
           :n_preallocs, :ushort,
           :instance_init, :g_instance_init_func,
           :value_table, :pointer
  end
  
  # GTypeFundamentalInfo:
  # @type_flags: #GTypeFundamentalFlags describing the characteristics of the fundamental type
  # 
  # A structure that provides information to the type system which is
  # used specifically for managing fundamental types.  
  # 
  # = Fields:
  # :type_flags ::
  #   (Symbol from _enum_g_type_fundamental_flags_) 
  class GTypeFundamentalInfo < FFI::Struct
    layout :type_flags, :g_type_fundamental_flags
  end
  
  # GInterfaceInfo:
  # @interface_init: location of the interface initialization function
  # @interface_finalize: location of the interface finalization function
  # @interface_data: user-supplied data passed to the interface init/finalize functions
  # 
  # A structure that provides information to the type system which is
  # used specifically for managing interface types.
  # 
  # = Fields:
  # :interface_init ::
  #   (Proc(_callback_g_interface_init_func_)) 
  # :interface_finalize ::
  #   (Proc(_callback_g_interface_finalize_func_)) 
  # :interface_data ::
  #   (FFI::Pointer(Gpointer)) 
  class GInterfaceInfo < FFI::Struct
    layout :interface_init, :g_interface_init_func,
           :interface_finalize, :g_interface_finalize_func,
           :interface_data, :pointer
  end
  
  # GTypeValueTable:
  # @value_init: Default initialize @values contents by poking values
  #  directly into the value->data array. The data array of
  #  the #GValue passed into this function was zero-filled
  #  with <function>memset()</function>, so no care has to
  #  be taken to free any
  #  old contents. E.g. for the implementation of a string
  #  value that may never be %NULL, the implementation might
  #  look like:
  #  |(
  #  value->data(0).v_pointer = g_strdup ("");
  #  )|
  # @value_free: Free any old contents that might be left in the
  #  data array of the passed in @value. No resources may
  #  remain allocated through the #GValue contents after
  #  this function returns. E.g. for our above string type:
  #  |(
  #  // only free strings without a specific flag for static storage
  #  if (!(value->data(1).v_uint & G_VALUE_NOCOPY_CONTENTS))
  #    g_free (value->data(0).v_pointer);
  #  )|
  # @value_copy: @dest_value is a #GValue with zero-filled data section
  #  and @src_value is a properly setup #GValue of same or
  #  derived type.
  #  The purpose of this function is to copy the contents of
  #  @src_value into @dest_value in a way, that even after
  #  @src_value has been freed, the contents of @dest_value
  #  remain valid. String type example:
  #  |(
  #  dest_value->data(0).v_pointer = g_strdup (src_value->data(0).v_pointer);
  #  )|
  # @value_peek_pointer: If the value contents fit into a pointer, such as objects
  #  or strings, return this pointer, so the caller can peek at
  #  the current contents. To extend on our above string example:
  #  |(
  #  return value->data(0).v_pointer;
  #  )|
  # @collect_format: A string format describing how to collect the contents of
  #  this value bit-by-bit. Each character in the format represents
  #  an argument to be collected, and the characters themselves indicate
  #  the type of the argument. Currently supported arguments are:
  #  <variablelist>
  #  <varlistentry><term /><listitem><para>
  #  'i' - Integers. passed as collect_values().v_int.
  #  </para></listitem></varlistentry>
  #  <varlistentry><term /><listitem><para>
  #  'l' - Longs. passed as collect_values().v_long.
  #  </para></listitem></varlistentry>
  #  <varlistentry><term /><listitem><para>
  #  'd' - Doubles. passed as collect_values().v_double.
  #  </para></listitem></varlistentry>
  #  <varlistentry><term /><listitem><para>
  #  'p' - Pointers. passed as collect_values().v_pointer.
  #  </para></listitem></varlistentry>
  #  </variablelist>
  #  It should be noted that for variable argument list construction,
  #  ANSI C promotes every type smaller than an integer to an int, and
  #  floats to doubles. So for collection of short int or char, 'i'
  #  needs to be used, and for collection of floats 'd'.
  # @collect_value: The collect_value() function is responsible for converting the
  #  values collected from a variable argument list into contents
  #  suitable for storage in a GValue. This function should setup
  #  @value similar to value_init(); e.g. for a string value that
  #  does not allow %NULL pointers, it needs to either spew an error,
  #  or do an implicit conversion by storing an empty string.
  #  The @value passed in to this function has a zero-filled data
  #  array, so just like for value_init() it is guaranteed to not
  #  contain any old contents that might need freeing.
  #  @n_collect_values is exactly the string length of @collect_format,
  #  and @collect_values is an array of unions #GTypeCValue with
  #  length @n_collect_values, containing the collected values
  #  according to @collect_format.
  #  @collect_flags is an argument provided as a hint by the caller.
  #  It may contain the flag %G_VALUE_NOCOPY_CONTENTS indicating,
  #  that the collected value contents may be considered "static"
  #  for the duration of the @value lifetime.
  #  Thus an extra copy of the contents stored in @collect_values is
  #  not required for assignment to @value.
  #  For our above string example, we continue with:
  #  |(
  #  if (!collect_values(0).v_pointer)
  #    value->data(0).v_pointer = g_strdup ("");
  #  else if (collect_flags & G_VALUE_NOCOPY_CONTENTS)
  #  {
  #    value->data(0).v_pointer = collect_values(0).v_pointer;
  #    // keep a flag for the value_free() implementation to not free this string
  #    value->data(1).v_uint = G_VALUE_NOCOPY_CONTENTS;
  #  }
  #  else
  #    value->data(0).v_pointer = g_strdup (collect_values(0).v_pointer);
  #  return NULL;
  #  )|
  #  It should be noted, that it is generally a bad idea to follow the
  #  #G_VALUE_NOCOPY_CONTENTS hint for reference counted types. Due to
  #  reentrancy requirements and reference count assertions performed
  #  by the signal emission code, reference counts should always be
  #  incremented for reference counted contents stored in the value->data
  #  array.  To deviate from our string example for a moment, and taking
  #  a look at an exemplary implementation for collect_value() of
  #  #GObject:
  #  |(
  #  if (collect_values(0).v_pointer)
  #  {
  #    GObject *object = G_OBJECT (collect_values(0).v_pointer);
  #    // never honour G_VALUE_NOCOPY_CONTENTS for ref-counted types
  #    value->data(0).v_pointer = g_object_ref (object);
  #    return NULL;
  #  }
  #  else
  #    return g_strdup_printf ("Object passed as invalid NULL pointer");
  #  }
  #  )|
  #  The reference count for valid objects is always incremented,
  #  regardless of @collect_flags. For invalid objects, the example
  #  returns a newly allocated string without altering @value.
  #  Upon success, collect_value() needs to return %NULL. If, however,
  #  an error condition occurred, collect_value() may spew an
  #  error by returning a newly allocated non-%NULL string, giving
  #  a suitable description of the error condition.
  #  The calling code makes no assumptions about the @value
  #  contents being valid upon error returns, @value
  #  is simply thrown away without further freeing. As such, it is
  #  a good idea to not allocate #GValue contents, prior to returning
  #  an error, however, collect_values() is not obliged to return
  #  a correctly setup @value for error returns, simply because
  #  any non-%NULL return is considered a fatal condition so further
  #  program behaviour is undefined.
  # @lcopy_format: Format description of the arguments to collect for @lcopy_value,
  #  analogous to @collect_format. Usually, @lcopy_format string consists
  #  only of 'p's to provide lcopy_value() with pointers to storage locations.
  # @lcopy_value: This function is responsible for storing the @value contents into
  #  arguments passed through a variable argument list which got
  #  collected into @collect_values according to @lcopy_format.
  #  @n_collect_values equals the string length of @lcopy_format,
  #  and @collect_flags may contain %G_VALUE_NOCOPY_CONTENTS.
  #  In contrast to collect_value(), lcopy_value() is obliged to
  #  always properly support %G_VALUE_NOCOPY_CONTENTS.
  #  Similar to collect_value() the function may prematurely abort
  #  by returning a newly allocated string describing an error condition.
  #  To complete the string example:
  #  |(
  #  gchar **string_p = collect_values(0).v_pointer;
  #  if (!string_p)
  #    return g_strdup_printf ("string location passed as NULL");
  #  if (collect_flags & G_VALUE_NOCOPY_CONTENTS)
  #    *string_p = value->data(0).v_pointer;
  #  else
  #    *string_p = g_strdup (value->data(0).v_pointer);
  #  )|
  #  And an illustrative version of lcopy_value() for
  #  reference-counted types:
  #  |(
  #  GObject **object_p = collect_values(0).v_pointer;
  #  if (!object_p)
  #    return g_strdup_printf ("object location passed as NULL");
  #  if (!value->data(0).v_pointer)
  #    *object_p = NULL;
  #  else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) /&ast; always honour &ast;/
  #    *object_p = value->data(0).v_pointer;
  #  else
  #    *object_p = g_object_ref (value->data(0).v_pointer);
  #  return NULL;
  #  )|
  # 
  # The #GTypeValueTable provides the functions required by the #GValue implementation,
  # to serve as a container for values of a type.
  # 
  # = Fields:
  # :value_init ::
  #   (FFI::Pointer(*)) 
  # :value_free ::
  #   (FFI::Pointer(*)) 
  # :value_copy ::
  #   (FFI::Pointer(*)) 
  # :value_peek_pointer ::
  #   (FFI::Pointer(*)) varargs functionality (optional)
  # :collect_format ::
  #   (String) 
  # :collect_value ::
  #   (FFI::Pointer(*)) 
  # :lcopy_format ::
  #   (String) 
  # :lcopy_value ::
  #   (FFI::Pointer(*)) 
  class GTypeValueTable < FFI::Struct
    layout :value_init, :pointer,
           :value_free, :pointer,
           :value_copy, :pointer,
           :value_peek_pointer, :pointer,
           :collect_format, :string,
           :collect_value, :pointer,
           :lcopy_format, :string,
           :lcopy_value, :pointer
  end
  
  # varargs functionality (optional)
  # 
  # @method type_register_static(parent_type, type_name, info, flags)
  # @param [Integer] parent_type 
  # @param [String] type_name 
  # @param [GTypeInfo] info 
  # @param [Symbol from _enum_g_type_flags_] flags 
  # @return [Integer] 
  # @scope class
  attach_function :type_register_static, :g_type_register_static, [:ulong, :string, GTypeInfo, :g_type_flags], :ulong
  
  # (Not documented)
  # 
  # @method type_register_static_simple(parent_type, type_name, class_size, class_init, instance_size, instance_init, flags)
  # @param [Integer] parent_type 
  # @param [String] type_name 
  # @param [Integer] class_size 
  # @param [Proc(_callback_g_class_init_func_)] class_init 
  # @param [Integer] instance_size 
  # @param [Proc(_callback_g_instance_init_func_)] instance_init 
  # @param [Symbol from _enum_g_type_flags_] flags 
  # @return [Integer] 
  # @scope class
  attach_function :type_register_static_simple, :g_type_register_static_simple, [:ulong, :string, :uint, :g_class_init_func, :uint, :g_instance_init_func, :g_type_flags], :ulong
  
  # (Not documented)
  # 
  # @method type_register_dynamic(parent_type, type_name, plugin, flags)
  # @param [Integer] parent_type 
  # @param [String] type_name 
  # @param [GTypePlugin] plugin 
  # @param [Symbol from _enum_g_type_flags_] flags 
  # @return [Integer] 
  # @scope class
  attach_function :type_register_dynamic, :g_type_register_dynamic, [:ulong, :string, GTypePlugin, :g_type_flags], :ulong
  
  # (Not documented)
  # 
  # @method type_register_fundamental(type_id, type_name, info, finfo, flags)
  # @param [Integer] type_id 
  # @param [String] type_name 
  # @param [GTypeInfo] info 
  # @param [GTypeFundamentalInfo] finfo 
  # @param [Symbol from _enum_g_type_flags_] flags 
  # @return [Integer] 
  # @scope class
  attach_function :type_register_fundamental, :g_type_register_fundamental, [:ulong, :string, GTypeInfo, GTypeFundamentalInfo, :g_type_flags], :ulong
  
  # (Not documented)
  # 
  # @method type_add_interface_static(instance_type, interface_type, info)
  # @param [Integer] instance_type 
  # @param [Integer] interface_type 
  # @param [GInterfaceInfo] info 
  # @return [nil] 
  # @scope class
  attach_function :type_add_interface_static, :g_type_add_interface_static, [:ulong, :ulong, GInterfaceInfo], :void
  
  # (Not documented)
  # 
  # @method type_add_interface_dynamic(instance_type, interface_type, plugin)
  # @param [Integer] instance_type 
  # @param [Integer] interface_type 
  # @param [GTypePlugin] plugin 
  # @return [nil] 
  # @scope class
  attach_function :type_add_interface_dynamic, :g_type_add_interface_dynamic, [:ulong, :ulong, GTypePlugin], :void
  
  # (Not documented)
  # 
  # @method type_interface_add_prerequisite(interface_type, prerequisite_type)
  # @param [Integer] interface_type 
  # @param [Integer] prerequisite_type 
  # @return [nil] 
  # @scope class
  attach_function :type_interface_add_prerequisite, :g_type_interface_add_prerequisite, [:ulong, :ulong], :void
  
  # (Not documented)
  # 
  # @method type_interface_prerequisites(interface_type, n_prerequisites)
  # @param [Integer] interface_type 
  # @param [FFI::Pointer(*Guint)] n_prerequisites 
  # @return [FFI::Pointer(*GType)] 
  # @scope class
  attach_function :type_interface_prerequisites, :g_type_interface_prerequisites, [:ulong, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method type_class_add_private(class, private_size)
  # @param [FFI::Pointer(Gpointer)] class 
  # @param [Integer] private_size 
  # @return [nil] 
  # @scope class
  attach_function :type_class_add_private, :g_type_class_add_private, [:pointer, :ulong], :void
  
  # (Not documented)
  # 
  # @method type_instance_get_private(instance, private_type)
  # @param [GTypeInstance] instance 
  # @param [Integer] private_type 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :type_instance_get_private, :g_type_instance_get_private, [GTypeInstance, :ulong], :pointer
  
  # (Not documented)
  # 
  # @method type_add_class_private(class_type, private_size)
  # @param [Integer] class_type 
  # @param [Integer] private_size 
  # @return [nil] 
  # @scope class
  attach_function :type_add_class_private, :g_type_add_class_private, [:ulong, :ulong], :void
  
  # (Not documented)
  # 
  # @method type_class_get_private(klass, private_type)
  # @param [GTypeClass] klass 
  # @param [Integer] private_type 
  # @return [FFI::Pointer(Gpointer)] 
  # @scope class
  attach_function :type_class_get_private, :g_type_class_get_private, [GTypeClass, :ulong], :pointer
  
  # --- protected (for fundamental type implementations) ---
  # 
  # @method type_get_plugin(type)
  # @param [Integer] type 
  # @return [GTypePlugin] 
  # @scope class
  attach_function :type_get_plugin, :g_type_get_plugin, [:ulong], GTypePlugin
  
  # (Not documented)
  # 
  # @method type_interface_get_plugin(instance_type, interface_type)
  # @param [Integer] instance_type 
  # @param [Integer] interface_type 
  # @return [GTypePlugin] 
  # @scope class
  attach_function :type_interface_get_plugin, :g_type_interface_get_plugin, [:ulong, :ulong], GTypePlugin
  
  # (Not documented)
  # 
  # @method type_fundamental_next()
  # @return [Integer] 
  # @scope class
  attach_function :type_fundamental_next, :g_type_fundamental_next, [], :ulong
  
  # (Not documented)
  # 
  # @method type_fundamental(type_id)
  # @param [Integer] type_id 
  # @return [Integer] 
  # @scope class
  attach_function :type_fundamental, :g_type_fundamental, [:ulong], :ulong
  
  # (Not documented)
  # 
  # @method type_create_instance(type)
  # @param [Integer] type 
  # @return [GTypeInstance] 
  # @scope class
  attach_function :type_create_instance, :g_type_create_instance, [:ulong], GTypeInstance
  
  # (Not documented)
  # 
  # @method type_free_instance(instance)
  # @param [GTypeInstance] instance 
  # @return [nil] 
  # @scope class
  attach_function :type_free_instance, :g_type_free_instance, [GTypeInstance], :void
  
  # (Not documented)
  # 
  # @method type_add_class_cache_func(cache_data, cache_func)
  # @param [FFI::Pointer(Gpointer)] cache_data 
  # @param [Proc(_callback_g_type_class_cache_func_)] cache_func 
  # @return [nil] 
  # @scope class
  attach_function :type_add_class_cache_func, :g_type_add_class_cache_func, [:pointer, :g_type_class_cache_func], :void
  
  # (Not documented)
  # 
  # @method type_remove_class_cache_func(cache_data, cache_func)
  # @param [FFI::Pointer(Gpointer)] cache_data 
  # @param [Proc(_callback_g_type_class_cache_func_)] cache_func 
  # @return [nil] 
  # @scope class
  attach_function :type_remove_class_cache_func, :g_type_remove_class_cache_func, [:pointer, :g_type_class_cache_func], :void
  
  # (Not documented)
  # 
  # @method type_class_unref_uncached(class)
  # @param [FFI::Pointer(Gpointer)] class 
  # @return [nil] 
  # @scope class
  attach_function :type_class_unref_uncached, :g_type_class_unref_uncached, [:pointer], :void
  
  # (Not documented)
  # 
  # @method type_add_interface_check(check_data, check_func)
  # @param [FFI::Pointer(Gpointer)] check_data 
  # @param [Proc(_callback_g_type_interface_check_func_)] check_func 
  # @return [nil] 
  # @scope class
  attach_function :type_add_interface_check, :g_type_add_interface_check, [:pointer, :g_type_interface_check_func], :void
  
  # (Not documented)
  # 
  # @method type_remove_interface_check(check_data, check_func)
  # @param [FFI::Pointer(Gpointer)] check_data 
  # @param [Proc(_callback_g_type_interface_check_func_)] check_func 
  # @return [nil] 
  # @scope class
  attach_function :type_remove_interface_check, :g_type_remove_interface_check, [:pointer, :g_type_interface_check_func], :void
  
  # (Not documented)
  # 
  # @method type_value_table_peek(type)
  # @param [Integer] type 
  # @return [GTypeValueTable] 
  # @scope class
  attach_function :type_value_table_peek, :g_type_value_table_peek, [:ulong], GTypeValueTable
  
  # < private >
  # 
  # @method type_check_instance(instance)
  # @param [GTypeInstance] instance 
  # @return [Integer] 
  # @scope class
  attach_function :type_check_instance, :g_type_check_instance, [GTypeInstance], :int
  
  # (Not documented)
  # 
  # @method type_check_instance_cast(instance, iface_type)
  # @param [GTypeInstance] instance 
  # @param [Integer] iface_type 
  # @return [GTypeInstance] 
  # @scope class
  attach_function :type_check_instance_cast, :g_type_check_instance_cast, [GTypeInstance, :ulong], GTypeInstance
  
  # (Not documented)
  # 
  # @method type_check_instance_is_a(instance, iface_type)
  # @param [GTypeInstance] instance 
  # @param [Integer] iface_type 
  # @return [Integer] 
  # @scope class
  attach_function :type_check_instance_is_a, :g_type_check_instance_is_a, [GTypeInstance, :ulong], :int
  
  # (Not documented)
  # 
  # @method type_check_class_cast(class, is_a_type)
  # @param [GTypeClass] class 
  # @param [Integer] is_a_type 
  # @return [GTypeClass] 
  # @scope class
  attach_function :type_check_class_cast, :g_type_check_class_cast, [GTypeClass, :ulong], GTypeClass
  
  # (Not documented)
  # 
  # @method type_check_class_is_a(class, is_a_type)
  # @param [GTypeClass] class 
  # @param [Integer] is_a_type 
  # @return [Integer] 
  # @scope class
  attach_function :type_check_class_is_a, :g_type_check_class_is_a, [GTypeClass, :ulong], :int
  
  # (Not documented)
  # 
  # @method type_check_is_value_type(type)
  # @param [Integer] type 
  # @return [Integer] 
  # @scope class
  attach_function :type_check_is_value_type, :g_type_check_is_value_type, [:ulong], :int
  
  # (Not documented)
  # 
  # @method type_check_value(value)
  # @param [GValue] value 
  # @return [Integer] 
  # @scope class
  attach_function :type_check_value, :g_type_check_value, [GValue], :int
  
  # (Not documented)
  # 
  # @method type_check_value_holds(value, type)
  # @param [GValue] value 
  # @param [Integer] type 
  # @return [Integer] 
  # @scope class
  attach_function :type_check_value_holds, :g_type_check_value_holds, [GValue, :ulong], :int
  
  # (Not documented)
  # 
  # @method type_test_flags(type, flags)
  # @param [Integer] type 
  # @param [Integer] flags 
  # @return [Integer] 
  # @scope class
  attach_function :type_test_flags, :g_type_test_flags, [:ulong, :uint], :int
  
  # --- debugging functions ---
  # 
  # @method type_name_from_instance(instance)
  # @param [GTypeInstance] instance 
  # @return [String] 
  # @scope class
  attach_function :type_name_from_instance, :g_type_name_from_instance, [GTypeInstance], :string
  
  # (Not documented)
  # 
  # @method type_name_from_class(class)
  # @param [GTypeClass] class 
  # @return [String] 
  # @scope class
  attach_function :type_name_from_class, :g_type_name_from_class, [GTypeClass], :string
  
  # GSignalEmissionHook:
  # @ihint: Signal invocation hint, see #GSignalInvocationHint.
  # @n_param_values: the number of parameters to the function, including
  #  the instance on which the signal was emitted.
  # @param_values: (array length=n_param_values): the instance on which
  #  the signal was emitted, followed by the parameters of the emission.
  # @data: user data associated with the hook.
  # 
  # A simple function pointer to get invoked when the signal is emitted. This 
  # allows you to tie a hook to the signal type, so that it will trap all 
  # emissions of that signal, from any object.
  # 
  # You may not attach these to signals created with the #G_SIGNAL_NO_HOOKS flag.
  # 
  # Returns: whether it wants to stay connected. If it returns %FALSE, the signal 
  #  hook is disconnected (and destroyed).
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_signal_emission_hook_(ihint, n_param_values, param_values, data)
  # @param [FFI::Pointer(*GSignalInvocationHint)] ihint 
  # @param [Integer] n_param_values 
  # @param [GValue] param_values 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  callback :g_signal_emission_hook, [:pointer, :uint, GValue, :pointer], :int
  
  # GSignalAccumulator:
  # @ihint: Signal invocation hint, see #GSignalInvocationHint.
  # @return_accu: Accumulator to collect callback return values in, this
  #  is the return value of the current signal emission.
  # @handler_return: A #GValue holding the return value of the signal handler.
  # @data: Callback data that was specified when creating the signal.
  # 
  # The signal accumulator is a special callback function that can be used
  # to collect return values of the various callbacks that are called
  # during a signal emission. The signal accumulator is specified at signal
  # creation time, if it is left %NULL, no accumulation of callback return
  # values is performed. The return value of signal emissions is then the
  # value returned by the last callback.
  # 
  # Returns: The accumulator function returns whether the signal emission
  #  should be aborted. Returning %FALSE means to abort the
  #  current emission and %TRUE is returned for continuation.
  # 
  # <em>This entry is only for documentation and no real method.</em>
  # 
  # @method _callback_g_signal_accumulator_(ihint, return_accu, handler_return, data)
  # @param [FFI::Pointer(*GSignalInvocationHint)] ihint 
  # @param [GValue] return_accu 
  # @param [GValue] handler_return 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  callback :g_signal_accumulator, [:pointer, GValue, GValue, :pointer], :int
  
  # GSignalFlags:
  # @G_SIGNAL_RUN_FIRST: Invoke the object method handler in the first emission stage.
  # @G_SIGNAL_RUN_LAST: Invoke the object method handler in the third emission stage.
  # @G_SIGNAL_RUN_CLEANUP: Invoke the object method handler in the last emission stage.
  # @G_SIGNAL_NO_RECURSE: Signals being emitted for an object while currently being in
  #  emission for this very object will not be emitted recursively,
  #  but instead cause the first emission to be restarted.
  # @G_SIGNAL_DETAILED: This signal supports "::detail" appendices to the signal name
  #  upon handler connections and emissions.
  # @G_SIGNAL_ACTION: Action signals are signals that may freely be emitted on alive
  #  objects from user code via g_signal_emit() and friends, without
  #  the need of being embedded into extra code that performs pre or
  #  post emission adjustments on the object. They can also be thought
  #  of as object methods which can be called generically by 
  #  third-party code.
  # @G_SIGNAL_NO_HOOKS: No emissions hooks are supported for this signal.
  # @G_SIGNAL_MUST_COLLECT: Varargs signal emission will always collect the
  #   arguments, even if there are no signal handlers connected.  Since 2.30.
  # 
  # The signal flags are used to specify a signal's behaviour, the overall
  # signal description outlines how especially the RUN flags control the
  # stages of a signal emission.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_signal_flags).</em>
  # 
  # === Options:
  # 
  # @method _enum_g_signal_flags_
  # @return [Symbol]
  # @scope class
  enum :g_signal_flags, [
  ]
  
  # GConnectFlags:
  # @G_CONNECT_AFTER: whether the handler should be called before or after the 
  #  default handler of the signal.
  # @G_CONNECT_SWAPPED: whether the instance and data should be swapped when
  #  calling the handler.
  # 
  # The connection flags are used to specify the behaviour of a signal's 
  # connection.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_connect_flags).</em>
  # 
  # === Options:
  # 
  # @method _enum_g_connect_flags_
  # @return [Symbol]
  # @scope class
  enum :g_connect_flags, [
  ]
  
  # GSignalMatchType:
  # @G_SIGNAL_MATCH_ID: The signal id must be equal.
  # @G_SIGNAL_MATCH_DETAIL: The signal detail be equal.
  # @G_SIGNAL_MATCH_CLOSURE: The closure must be the same.
  # @G_SIGNAL_MATCH_FUNC: The C closure callback must be the same.
  # @G_SIGNAL_MATCH_DATA: The closure data must be the same.
  # @G_SIGNAL_MATCH_UNBLOCKED: Only unblocked signals may matched.
  # 
  # The match types specify what g_signal_handlers_block_matched(),
  # g_signal_handlers_unblock_matched() and g_signal_handlers_disconnect_matched()
  # match signals by.
  # 
  # <em>This entry is only for documentation and no real method. The FFI::Enum can be accessed via #enum_type(:g_signal_match_type).</em>
  # 
  # === Options:
  # 
  # @method _enum_g_signal_match_type_
  # @return [Symbol]
  # @scope class
  enum :g_signal_match_type, [
  ]
  
  # GSignalInvocationHint:
  # @signal_id: The signal id of the signal invoking the callback
  # @detail: The detail passed on for this emission
  # @run_type: The stage the signal emission is currently in, this
  #  field will contain one of %G_SIGNAL_RUN_FIRST,
  #  %G_SIGNAL_RUN_LAST or %G_SIGNAL_RUN_CLEANUP.
  # 
  # The #GSignalInvocationHint structure is used to pass on additional information
  # to callbacks during a signal emission.
  # 
  # = Fields:
  # :signal_id ::
  #   (Integer) 
  # :detail ::
  #   (Integer) 
  # :run_type ::
  #   (Symbol from _enum_g_signal_flags_) 
  class GSignalInvocationHint < FFI::Struct
    layout :signal_id, :uint,
           :detail, :uint,
           :run_type, :g_signal_flags
  end
  
  # GSignalQuery:
  # @signal_id: The signal id of the signal being queried, or 0 if the
  #  signal to be queried was unknown.
  # @signal_name: The signal name.
  # @itype: The interface/instance type that this signal can be emitted for.
  # @signal_flags: The signal flags as passed in to g_signal_new().
  # @return_type: The return type for user callbacks.
  # @n_params: The number of parameters that user callbacks take.
  # @param_types: The individual parameter types for user callbacks, note that the
  #  effective callback signature is:
  #  <programlisting>
  #  @return_type callback (#gpointer     data1,
  #  (param_types param_names,)
  #  gpointer     data2);
  #  </programlisting>
  # 
  # A structure holding in-depth information for a specific signal. It is
  # filled in by the g_signal_query() function.
  # 
  # = Fields:
  # :signal_id ::
  #   (Integer) 
  # :signal_name ::
  #   (String) 
  # :itype ::
  #   (Integer) 
  # :signal_flags ::
  #   (Symbol from _enum_g_signal_flags_) 
  # :return_type ::
  #   (Integer) mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag
  # :n_params ::
  #   (Integer) 
  # :param_types ::
  #   (FFI::Pointer(*GType)) mangled with G_SIGNAL_TYPE_STATIC_SCOPE flag
  class GSignalQuery < FFI::Struct
    layout :signal_id, :uint,
           :signal_name, :string,
           :itype, :ulong,
           :signal_flags, :g_signal_flags,
           :return_type, :ulong,
           :n_params, :uint,
           :param_types, :pointer
  end
  
  # --- signals ---
  # 
  # @method signal_newv(signal_name, itype, signal_flags, class_closure, accumulator, accu_data, c_marshaller, return_type, n_params, param_types)
  # @param [String] signal_name 
  # @param [Integer] itype 
  # @param [Symbol from _enum_g_signal_flags_] signal_flags 
  # @param [FFI::Pointer(*GClosure)] class_closure 
  # @param [Proc(_callback_g_signal_accumulator_)] accumulator 
  # @param [FFI::Pointer(Gpointer)] accu_data 
  # @param [FFI::Pointer(GSignalCMarshaller)] c_marshaller 
  # @param [Integer] return_type 
  # @param [Integer] n_params 
  # @param [FFI::Pointer(*GType)] param_types 
  # @return [Integer] 
  # @scope class
  attach_function :signal_newv, :g_signal_newv, [:string, :ulong, :g_signal_flags, :pointer, :g_signal_accumulator, :pointer, :pointer, :ulong, :uint, :pointer], :uint
  
  # (Not documented)
  # 
  # @method signal_new_valist(signal_name, itype, signal_flags, class_closure, accumulator, accu_data, c_marshaller, return_type, n_params, args)
  # @param [String] signal_name 
  # @param [Integer] itype 
  # @param [Symbol from _enum_g_signal_flags_] signal_flags 
  # @param [FFI::Pointer(*GClosure)] class_closure 
  # @param [Proc(_callback_g_signal_accumulator_)] accumulator 
  # @param [FFI::Pointer(Gpointer)] accu_data 
  # @param [FFI::Pointer(GSignalCMarshaller)] c_marshaller 
  # @param [Integer] return_type 
  # @param [Integer] n_params 
  # @param [FFI::Pointer(*VaListTag)] args 
  # @return [Integer] 
  # @scope class
  attach_function :signal_new_valist, :g_signal_new_valist, [:string, :ulong, :g_signal_flags, :pointer, :g_signal_accumulator, :pointer, :pointer, :ulong, :uint, :pointer], :uint
  
  # (Not documented)
  # 
  # @method signal_new(signal_name, itype, signal_flags, class_offset, accumulator, accu_data, c_marshaller, return_type, n_params)
  # @param [String] signal_name 
  # @param [Integer] itype 
  # @param [Symbol from _enum_g_signal_flags_] signal_flags 
  # @param [Integer] class_offset 
  # @param [Proc(_callback_g_signal_accumulator_)] accumulator 
  # @param [FFI::Pointer(Gpointer)] accu_data 
  # @param [FFI::Pointer(GSignalCMarshaller)] c_marshaller 
  # @param [Integer] return_type 
  # @param [Integer] n_params 
  # @return [Integer] 
  # @scope class
  attach_function :signal_new, :g_signal_new, [:string, :ulong, :g_signal_flags, :uint, :g_signal_accumulator, :pointer, :pointer, :ulong, :uint], :uint
  
  # (Not documented)
  # 
  # @method signal_new_class_handler(signal_name, itype, signal_flags, class_handler, accumulator, accu_data, c_marshaller, return_type, n_params)
  # @param [String] signal_name 
  # @param [Integer] itype 
  # @param [Symbol from _enum_g_signal_flags_] signal_flags 
  # @param [FFI::Pointer(GCallback)] class_handler 
  # @param [Proc(_callback_g_signal_accumulator_)] accumulator 
  # @param [FFI::Pointer(Gpointer)] accu_data 
  # @param [FFI::Pointer(GSignalCMarshaller)] c_marshaller 
  # @param [Integer] return_type 
  # @param [Integer] n_params 
  # @return [Integer] 
  # @scope class
  attach_function :signal_new_class_handler, :g_signal_new_class_handler, [:string, :ulong, :g_signal_flags, :pointer, :g_signal_accumulator, :pointer, :pointer, :ulong, :uint], :uint
  
  # (Not documented)
  # 
  # @method signal_emitv(instance_and_params, signal_id, detail, return_value)
  # @param [GValue] instance_and_params 
  # @param [Integer] signal_id 
  # @param [Integer] detail 
  # @param [GValue] return_value 
  # @return [nil] 
  # @scope class
  attach_function :signal_emitv, :g_signal_emitv, [GValue, :uint, :uint, GValue], :void
  
  # (Not documented)
  # 
  # @method signal_emit_valist(instance, signal_id, detail, var_args)
  # @param [FFI::Pointer(Gpointer)] instance 
  # @param [Integer] signal_id 
  # @param [Integer] detail 
  # @param [FFI::Pointer(*VaListTag)] var_args 
  # @return [nil] 
  # @scope class
  attach_function :signal_emit_valist, :g_signal_emit_valist, [:pointer, :uint, :uint, :pointer], :void
  
  # (Not documented)
  # 
  # @method signal_emit(instance, signal_id, detail)
  # @param [FFI::Pointer(Gpointer)] instance 
  # @param [Integer] signal_id 
  # @param [Integer] detail 
  # @return [nil] 
  # @scope class
  attach_function :signal_emit, :g_signal_emit, [:pointer, :uint, :uint], :void
  
  # (Not documented)
  # 
  # @method signal_emit_by_name(instance, detailed_signal)
  # @param [FFI::Pointer(Gpointer)] instance 
  # @param [String] detailed_signal 
  # @return [nil] 
  # @scope class
  attach_function :signal_emit_by_name, :g_signal_emit_by_name, [:pointer, :string], :void
  
  # (Not documented)
  # 
  # @method signal_lookup(name, itype)
  # @param [String] name 
  # @param [Integer] itype 
  # @return [Integer] 
  # @scope class
  attach_function :signal_lookup, :g_signal_lookup, [:string, :ulong], :uint
  
  # (Not documented)
  # 
  # @method signal_name(signal_id)
  # @param [Integer] signal_id 
  # @return [String] 
  # @scope class
  attach_function :signal_name, :g_signal_name, [:uint], :string
  
  # (Not documented)
  # 
  # @method signal_query(signal_id, query)
  # @param [Integer] signal_id 
  # @param [GSignalQuery] query 
  # @return [nil] 
  # @scope class
  attach_function :signal_query, :g_signal_query, [:uint, GSignalQuery], :void
  
  # (Not documented)
  # 
  # @method signal_list_ids(itype, n_ids)
  # @param [Integer] itype 
  # @param [FFI::Pointer(*Guint)] n_ids 
  # @return [FFI::Pointer(*Guint)] 
  # @scope class
  attach_function :signal_list_ids, :g_signal_list_ids, [:ulong, :pointer], :pointer
  
  # (Not documented)
  # 
  # @method signal_parse_name(detailed_signal, itype, signal_id_p, detail_p, force_detail_quark)
  # @param [String] detailed_signal 
  # @param [Integer] itype 
  # @param [FFI::Pointer(*Guint)] signal_id_p 
  # @param [FFI::Pointer(*GQuark)] detail_p 
  # @param [Integer] force_detail_quark 
  # @return [Integer] 
  # @scope class
  attach_function :signal_parse_name, :g_signal_parse_name, [:string, :ulong, :pointer, :pointer, :int], :int
  
  # (Not documented)
  # 
  # @method signal_get_invocation_hint(instance)
  # @param [FFI::Pointer(Gpointer)] instance 
  # @return [GSignalInvocationHint] 
  # @scope class
  attach_function :signal_get_invocation_hint, :g_signal_get_invocation_hint, [:pointer], GSignalInvocationHint
  
  # --- signal emissions ---
  # 
  # @method signal_stop_emission(instance, signal_id, detail)
  # @param [FFI::Pointer(Gpointer)] instance 
  # @param [Integer] signal_id 
  # @param [Integer] detail 
  # @return [nil] 
  # @scope class
  attach_function :signal_stop_emission, :g_signal_stop_emission, [:pointer, :uint, :uint], :void
  
  # (Not documented)
  # 
  # @method signal_stop_emission_by_name(instance, detailed_signal)
  # @param [FFI::Pointer(Gpointer)] instance 
  # @param [String] detailed_signal 
  # @return [nil] 
  # @scope class
  attach_function :signal_stop_emission_by_name, :g_signal_stop_emission_by_name, [:pointer, :string], :void
  
  # (Not documented)
  # 
  # @method signal_add_emission_hook(signal_id, detail, hook_func, hook_data, data_destroy)
  # @param [Integer] signal_id 
  # @param [Integer] detail 
  # @param [Proc(_callback_g_signal_emission_hook_)] hook_func 
  # @param [FFI::Pointer(Gpointer)] hook_data 
  # @param [FFI::Pointer(GDestroyNotify)] data_destroy 
  # @return [Integer] 
  # @scope class
  attach_function :signal_add_emission_hook, :g_signal_add_emission_hook, [:uint, :uint, :g_signal_emission_hook, :pointer, :pointer], :ulong
  
  # (Not documented)
  # 
  # @method signal_remove_emission_hook(signal_id, hook_id)
  # @param [Integer] signal_id 
  # @param [Integer] hook_id 
  # @return [nil] 
  # @scope class
  attach_function :signal_remove_emission_hook, :g_signal_remove_emission_hook, [:uint, :ulong], :void
  
  # --- signal handlers ---
  # 
  # @method signal_has_handler_pending(instance, signal_id, detail, may_be_blocked)
  # @param [FFI::Pointer(Gpointer)] instance 
  # @param [Integer] signal_id 
  # @param [Integer] detail 
  # @param [Integer] may_be_blocked 
  # @return [Integer] 
  # @scope class
  attach_function :signal_has_handler_pending, :g_signal_has_handler_pending, [:pointer, :uint, :uint, :int], :int
  
  # (Not documented)
  # 
  # @method signal_connect_closure_by_id(instance, signal_id, detail, closure, after)
  # @param [FFI::Pointer(Gpointer)] instance 
  # @param [Integer] signal_id 
  # @param [Integer] detail 
  # @param [FFI::Pointer(*GClosure)] closure 
  # @param [Integer] after 
  # @return [Integer] 
  # @scope class
  attach_function :signal_connect_closure_by_id, :g_signal_connect_closure_by_id, [:pointer, :uint, :uint, :pointer, :int], :ulong
  
  # (Not documented)
  # 
  # @method signal_connect_closure(instance, detailed_signal, closure, after)
  # @param [FFI::Pointer(Gpointer)] instance 
  # @param [String] detailed_signal 
  # @param [FFI::Pointer(*GClosure)] closure 
  # @param [Integer] after 
  # @return [Integer] 
  # @scope class
  attach_function :signal_connect_closure, :g_signal_connect_closure, [:pointer, :string, :pointer, :int], :ulong
  
  # (Not documented)
  # 
  # @method signal_connect_data(instance, detailed_signal, c_handler, data, destroy_data, connect_flags)
  # @param [FFI::Pointer(Gpointer)] instance 
  # @param [String] detailed_signal 
  # @param [FFI::Pointer(GCallback)] c_handler 
  # @param [FFI::Pointer(Gpointer)] data 
  # @param [FFI::Pointer(GClosureNotify)] destroy_data 
  # @param [Symbol from _enum_g_connect_flags_] connect_flags 
  # @return [Integer] 
  # @scope class
  attach_function :signal_connect_data, :g_signal_connect_data, [:pointer, :string, :pointer, :pointer, :pointer, :g_connect_flags], :ulong
  
  # (Not documented)
  # 
  # @method signal_handler_block(instance, handler_id)
  # @param [FFI::Pointer(Gpointer)] instance 
  # @param [Integer] handler_id 
  # @return [nil] 
  # @scope class
  attach_function :signal_handler_block, :g_signal_handler_block, [:pointer, :ulong], :void
  
  # (Not documented)
  # 
  # @method signal_handler_unblock(instance, handler_id)
  # @param [FFI::Pointer(Gpointer)] instance 
  # @param [Integer] handler_id 
  # @return [nil] 
  # @scope class
  attach_function :signal_handler_unblock, :g_signal_handler_unblock, [:pointer, :ulong], :void
  
  # (Not documented)
  # 
  # @method signal_handler_disconnect(instance, handler_id)
  # @param [FFI::Pointer(Gpointer)] instance 
  # @param [Integer] handler_id 
  # @return [nil] 
  # @scope class
  attach_function :signal_handler_disconnect, :g_signal_handler_disconnect, [:pointer, :ulong], :void
  
  # (Not documented)
  # 
  # @method signal_handler_is_connected(instance, handler_id)
  # @param [FFI::Pointer(Gpointer)] instance 
  # @param [Integer] handler_id 
  # @return [Integer] 
  # @scope class
  attach_function :signal_handler_is_connected, :g_signal_handler_is_connected, [:pointer, :ulong], :int
  
  # (Not documented)
  # 
  # @method signal_handler_find(instance, mask, signal_id, detail, closure, func, data)
  # @param [FFI::Pointer(Gpointer)] instance 
  # @param [Symbol from _enum_g_signal_match_type_] mask 
  # @param [Integer] signal_id 
  # @param [Integer] detail 
  # @param [FFI::Pointer(*GClosure)] closure 
  # @param [FFI::Pointer(Gpointer)] func 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  attach_function :signal_handler_find, :g_signal_handler_find, [:pointer, :g_signal_match_type, :uint, :uint, :pointer, :pointer, :pointer], :ulong
  
  # (Not documented)
  # 
  # @method signal_handlers_block_matched(instance, mask, signal_id, detail, closure, func, data)
  # @param [FFI::Pointer(Gpointer)] instance 
  # @param [Symbol from _enum_g_signal_match_type_] mask 
  # @param [Integer] signal_id 
  # @param [Integer] detail 
  # @param [FFI::Pointer(*GClosure)] closure 
  # @param [FFI::Pointer(Gpointer)] func 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  attach_function :signal_handlers_block_matched, :g_signal_handlers_block_matched, [:pointer, :g_signal_match_type, :uint, :uint, :pointer, :pointer, :pointer], :uint
  
  # (Not documented)
  # 
  # @method signal_handlers_unblock_matched(instance, mask, signal_id, detail, closure, func, data)
  # @param [FFI::Pointer(Gpointer)] instance 
  # @param [Symbol from _enum_g_signal_match_type_] mask 
  # @param [Integer] signal_id 
  # @param [Integer] detail 
  # @param [FFI::Pointer(*GClosure)] closure 
  # @param [FFI::Pointer(Gpointer)] func 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  attach_function :signal_handlers_unblock_matched, :g_signal_handlers_unblock_matched, [:pointer, :g_signal_match_type, :uint, :uint, :pointer, :pointer, :pointer], :uint
  
  # (Not documented)
  # 
  # @method signal_handlers_disconnect_matched(instance, mask, signal_id, detail, closure, func, data)
  # @param [FFI::Pointer(Gpointer)] instance 
  # @param [Symbol from _enum_g_signal_match_type_] mask 
  # @param [Integer] signal_id 
  # @param [Integer] detail 
  # @param [FFI::Pointer(*GClosure)] closure 
  # @param [FFI::Pointer(Gpointer)] func 
  # @param [FFI::Pointer(Gpointer)] data 
  # @return [Integer] 
  # @scope class
  attach_function :signal_handlers_disconnect_matched, :g_signal_handlers_disconnect_matched, [:pointer, :g_signal_match_type, :uint, :uint, :pointer, :pointer, :pointer], :uint
  
  # --- overriding and chaining ---
  # 
  # @method signal_override_class_closure(signal_id, instance_type, class_closure)
  # @param [Integer] signal_id 
  # @param [Integer] instance_type 
  # @param [FFI::Pointer(*GClosure)] class_closure 
  # @return [nil] 
  # @scope class
  attach_function :signal_override_class_closure, :g_signal_override_class_closure, [:uint, :ulong, :pointer], :void
  
  # (Not documented)
  # 
  # @method signal_override_class_handler(signal_name, instance_type, class_handler)
  # @param [String] signal_name 
  # @param [Integer] instance_type 
  # @param [FFI::Pointer(GCallback)] class_handler 
  # @return [nil] 
  # @scope class
  attach_function :signal_override_class_handler, :g_signal_override_class_handler, [:string, :ulong, :pointer], :void
  
  # (Not documented)
  # 
  # @method signal_chain_from_overridden(instance_and_params, return_value)
  # @param [GValue] instance_and_params 
  # @param [GValue] return_value 
  # @return [nil] 
  # @scope class
  attach_function :signal_chain_from_overridden, :g_signal_chain_from_overridden, [GValue, GValue], :void
  
  # (Not documented)
  # 
  # @method signal_chain_from_overridden_handler(instance)
  # @param [FFI::Pointer(Gpointer)] instance 
  # @return [nil] 
  # @scope class
  attach_function :signal_chain_from_overridden_handler, :g_signal_chain_from_overridden_handler, [:pointer], :void
  
  # g_signal_handlers_unblock_by_func:
  # @instance: The instance to unblock handlers from.
  # @func: The C closure callback of the handlers (useless for non-C closures).
  # @data: The closure data of the handlers' closures.
  # 
  # Unblocks all handlers on an instance that match @func and @data.
  # 
  # Returns: The number of handlers that matched.
  # 
  # @method signal_accumulator_true_handled(ihint, return_accu, handler_return, dummy)
  # @param [GSignalInvocationHint] ihint 
  # @param [GValue] return_accu 
  # @param [GValue] handler_return 
  # @param [FFI::Pointer(Gpointer)] dummy 
  # @return [Integer] 
  # @scope class
  attach_function :signal_accumulator_true_handled, :g_signal_accumulator_true_handled, [GSignalInvocationHint, GValue, GValue, :pointer], :int
  
  # (Not documented)
  # 
  # @method signal_accumulator_first_wins(ihint, return_accu, handler_return, dummy)
  # @param [GSignalInvocationHint] ihint 
  # @param [GValue] return_accu 
  # @param [GValue] handler_return 
  # @param [FFI::Pointer(Gpointer)] dummy 
  # @return [Integer] 
  # @scope class
  attach_function :signal_accumulator_first_wins, :g_signal_accumulator_first_wins, [GSignalInvocationHint, GValue, GValue, :pointer], :int
  
  # < private >
  # 
  # @method signal_handlers_destroy(instance)
  # @param [FFI::Pointer(Gpointer)] instance 
  # @return [nil] 
  # @scope class
  attach_function :signal_handlers_destroy, :g_signal_handlers_destroy, [:pointer], :void
  
end
